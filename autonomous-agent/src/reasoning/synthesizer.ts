/**
 * Results Synthesizer
 * Uses Claude to synthesize results from multiple MCPs into actionable recommendations
 */

import Anthropic from '@anthropic-ai/sdk';
import type { ExecutionResult } from '../orchestrator/executor';

export interface Synthesis {
  summary: string;
  keyFindings: string[];
  recommendation: string;
  confidence: number;
  reasoning: string;
  actionItems?: string[];
}

/**
 * Synthesize execution results into final recommendation
 */
export async function synthesizeResults(
  userQuery: string,
  executionResult: ExecutionResult,
  anthropicApiKey: string
): Promise<Synthesis> {
  const anthropic = new Anthropic({ apiKey: anthropicApiKey });

  const prompt = `You are an AI agent synthesizing results from blockchain analysis tools.

Original User Query: "${userQuery}"

Execution Plan:
${JSON.stringify(executionResult.plan, null, 2)}

Results from MCP Tools:
${JSON.stringify(executionResult.results, null, 2)}

Total Cost: ${executionResult.totalCost} ETH
Execution Time: ${executionResult.executionTime}ms

Synthesize these results into a clear, factual response:
1. A concise summary answering the user's question based on the data
2. Key findings from the analysis (factual observations)
3. A recommendation ONLY if the user explicitly asked for one (e.g., "should I follow this wallet?")
   - If no recommendation was requested, use "INFORMATIONAL" as the recommendation
4. Confidence level (0-1) in the analysis quality
5. Reasoning explaining the findings
6. Optional action items if relevant to the query

Respond in this exact JSON format:
{
  "summary": "Brief factual summary of the wallet/analysis",
  "keyFindings": [
    "Factual finding 1",
    "Factual finding 2",
    "Factual finding 3"
  ],
  "recommendation": "INFORMATIONAL | FOLLOW | WATCH | AVOID (only if explicitly asked)",
  "confidence": 0.85,
  "reasoning": "Explanation of the findings based on the data",
  "actionItems": [
    "Action 1 (only if relevant)",
    "Action 2"
  ]
}

IMPORTANT RULES:
- If the data shows "isTestnet: true" or network contains "Sepolia", DO NOT calculate USD values
- Testnet ETH has NO real-world value - never convert to USD
- Always mention the network name (e.g., "Base Sepolia Testnet") in your summary
- Balance values are already in ETH (not Wei) - use them directly
- Example: "0.0527 ETH on Base Sepolia Testnet" NOT "$92 worth of ETH"

Be objective and factual. Focus on what the data shows, not assumptions about intent or strategy.`;

  const message = await anthropic.messages.create({
    model: 'claude-3-haiku-20240307',
    max_tokens: 2048,
    messages: [{
      role: 'user',
      content: prompt
    }]
  });

  const textContent = message.content.find(block => block.type === 'text');
  const responseText = textContent ? (textContent as any).text : '{}';

  try {
    // Extract JSON from response
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    const jsonStr = jsonMatch ? jsonMatch[0] : responseText;
    const synthesis = JSON.parse(jsonStr);

    return synthesis as Synthesis;
  } catch (error) {
    throw new Error(`Failed to parse synthesis: ${error}`);
  }
}

/**
 * Generate human-readable report
 */
export function generateReport(
  userQuery: string,
  executionResult: ExecutionResult,
  synthesis: Synthesis
): string {
  const { plan, results, totalCost, executionTime } = executionResult;

  let report = `# Analysis Report\n\n`;
  report += `**Query:** ${userQuery}\n\n`;
  report += `---\n\n`;

  // Summary
  report += `## Summary\n\n`;
  report += `${synthesis.summary}\n\n`;

  // Recommendation
  report += `## Recommendation: ${synthesis.recommendation}\n\n`;
  report += `**Confidence:** ${Math.round(synthesis.confidence * 100)}%\n\n`;
  report += `${synthesis.reasoning}\n\n`;

  // Key Findings
  report += `## Key Findings\n\n`;
  synthesis.keyFindings.forEach((finding, idx) => {
    report += `${idx + 1}. ${finding}\n`;
  });
  report += `\n`;

  // Action Items
  if (synthesis.actionItems && synthesis.actionItems.length > 0) {
    report += `## Recommended Actions\n\n`;
    synthesis.actionItems.forEach((action, idx) => {
      report += `- [ ] ${action}\n`;
    });
    report += `\n`;
  }

  // Execution Details
  report += `---\n\n`;
  report += `## Execution Details\n\n`;
  report += `**Tools Used:** ${plan.steps.length}\n`;
  report += `**Total Cost:** ${totalCost.toFixed(4)} ETH\n`;
  report += `**Execution Time:** ${(executionTime / 1000).toFixed(2)}s\n\n`;

  // Step-by-step results
  report += `### Tools Executed\n\n`;
  results.forEach((result, idx) => {
    const step = plan.steps[result.step];
    report += `${idx + 1}. **${step.mcp}::${step.tool}**\n`;
    report += `   - Reason: ${step.reason}\n`;
    report += `   - Status: ${result.success ? '✅ Success' : '❌ Failed'}\n`;
    if (result.error) {
      report += `   - Error: ${result.error}\n`;
    }
    report += `\n`;
  });

  report += `---\n\n`;
  report += `*Generated by AetheraOS Autonomous Agent*\n`;

  return report;
}

/**
 * Create conversational response showing agent thinking
 */
export function generateConversation(
  userQuery: string,
  plan: any,
  executionResult: ExecutionResult,
  synthesis: Synthesis
): string[] {
  const conversation: string[] = [];

  // User message
  conversation.push(`**You:** ${userQuery}`);

  // Agent thinking (planning)
  conversation.push(`**Agent:** Let me analyze this... I'll need to:`);
  plan.steps.forEach((step: any, idx: number) => {
    conversation.push(`  ${idx + 1}. ${step.reason} (using ${step.mcp}::${step.tool})`);
  });
  conversation.push(`Total cost will be: ${plan.totalCost}`);

  // Agent executing
  conversation.push(`**Agent:** Executing analysis...`);

  executionResult.results.forEach((result, idx) => {
    const step = plan.steps[result.step];
    if (result.success) {
      conversation.push(`  ✅ Completed ${step.tool}`);
    } else {
      conversation.push(`  ❌ Failed ${step.tool}: ${result.error}`);
    }
  });

  // Agent synthesizing
  conversation.push(`**Agent:** Synthesizing results...`);

  // Final recommendation
  conversation.push(`**Agent:** Based on my analysis:`);
  conversation.push(``);
  conversation.push(synthesis.summary);
  conversation.push(``);
  conversation.push(`**My recommendation:** ${synthesis.recommendation}`);
  conversation.push(``);
  conversation.push(`**Key findings:**`);
  synthesis.keyFindings.forEach((finding, idx) => {
    conversation.push(`${idx + 1}. ${finding}`);
  });

  if (synthesis.actionItems && synthesis.actionItems.length > 0) {
    conversation.push(``);
    conversation.push(`**Suggested actions:**`);
    synthesis.actionItems.forEach((action) => {
      conversation.push(`• ${action}`);
    });
  }

  conversation.push(``);
  conversation.push(`*Confidence: ${Math.round(synthesis.confidence * 100)}%*`);

  return conversation;
}
